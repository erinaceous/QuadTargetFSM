[camera]
; index is usually 0 unless you have multiple webcams.
; file = /tmp/sd/flight_1435671703.48.mp4
; file = /tmp/sd/flight_1435933737.8.mp4
; file = /home/owain/Dropbox/Aber/MSc_Dissertation/data/synthetic_targets-3.mp4
; file = /everything/quad_data/markers/rescaled_64/%04d.png
; file = test7.png
; file = Target2.png
; file = /home/owain/flight1.mp4
; file = /everything/quad_data/data/15jun15-afternoon_flight.mp4
; file = /everything/quad_data/data/flight_1435933737.8.h264
; file = /home/owain/Dropbox/Aber/MSc_Dissertation/code/QuadTargetFSM/quadtargetfsm_webcam.mp4
; file = 0
; file = /tmp/frontsensor.rgb
file = localhost:5011

; width and height are ignored for video files.
width = 800
height = 600

; set FPS to -1 to capture as fast as camera will allow.
fps = 10

; sets CV_CAP_PROP_CONVERT_RGB to this value.
; most V4l2 webcam drivers I've tried don't support this,
; so they ignore it and give you an RGB (well, BGR in OpenCV)
; image anyway -- but the Pi Cam seems to support it! which saves
; us some CPU cycles.
convert_rgb = true

; if the webcam image is RGB, converts to YUV.
convert_yuv = true

; the camera on my pi is mounted upside down, so flipping image is needed.
flip_vertical = false
flip_horizontal = false

; (float) focal length of the camera being used, in mm.
focal_length = 3.6

; (float) magnification factor - used when attaching lenses.
; my wide angle lens magnifies focal length by 0.4.
magnification_factor = 0.4

; (float) sensor width of camera, in mm.
sensor_width = 3.67

; (float) offset the angle of detected targets by this much.
; (they are being detected at 90 degrees less than they should be
; so far). value is in radians.
angle_offset = 1.57079632679

[gui]
; if headless, no GUI is shown at all. this reduces CPU usage.
headless = false
; how long to wait for key input (to advance frame by frame).
; -1 is forever, 0 is not at all, >=1 is time in milliseconds.
waitKey = 1
; if debug is true, it'll spit more info out on command line.
debug = true
; if save_video is not none, it'll save debug output to this file.
save_video = /tmp/quadtargetfsm_vrep.avi
; save_video = none
; if show_state is true, show the state of the state machines
; (in the output image).
show_state = true

[target]
; (floats) real physical dimensions of the target used, in mm.
; width = 594
; height = 420
width = 297
height = 210

[navigator]
; (float) "dead zones" for control. if the marker is off-center
; by less than these amounts on their respective axes, don't
; request the quadcopter move position.
; rotation is in DEGREES.
rotation_deadzone = 30.0
; these two are scalar values from 0.0 to 0.1 -- the real dead
; zones are calculated from the webcam image dimensions.
; e.g. deadzone_x = (center.x) +- (image.rows * horizontal_deadzone)
horizontal_deadzone = 0.01
vertical_deadzone = 0.01
alpha = 0.3

[parameters]
; (int) skip every N rows of the image
row_step = 2

; (int) minimum number of pixels needed in state 1 of the state machine.
min_length = 1

; (double) amount of variation in pixel counts that each state can have
; compared to state 1.
tolerance = 0.7

; (int) number of threshold levels used.
num_bins = 2

; (double) amount that the marker aspect ratio can vary
; (with 0.0 being completely square)
marker_aspect_tolerance = 0.2

; (double) minimum distance between markers in a target
min_marker_distance = 0.8

; (double) maximum distance between markers in a target
max_marker_distance = 3.0

; (double) amount that the marker size can vary in a
; target.
; (actual tolerance = 1.0 - this)
; decreasing this means potentially markers
; with a more skewed perspective will be
; detected.
marker_size_tolerance = 0.5

; (float) amount of seconds a target can go undetected before
; it's removed from the list.
target_lifetime = 3.0

; (float) smoothness factor applied when updating
; existing targets with newly detected ones.
target_alpha = 0.3

; (float) similarity threshold for detected targets.
;
