[camera]
; index is usually 0 unless you have multiple webcams.
; file = /tmp/sd/flight_1435671703.48.mp4
; file = /tmp/sd/flight_1435933737.8.mp4
; file = /home/owain/Dropbox/Aber/MSc_Dissertation/data/synthetic_targets-3.mp4
; file = /everything/quad_data/markers/rescaled_64/%04d.png
; file = test7.png
; file = Target2.png
; file = /home/owain/flight1.mp4
; file = /everything/quad_data/data/15jun15-afternoon_flight.mp4
; file = /everything/quad_data/data/flight_1435933737.8.h264
; file = /home/owain/Dropbox/Aber/MSc_Dissertation/code/QuadTargetFSM/quadtargetfsm_webcam.mp4
file = 0

; width and height are ignored for video files.
width = 800
height = 600

; set FPS to -1 to capture as fast as camera will allow.
fps = 0

; sets CV_CAP_PROP_CONVERT_RGB to this value.
; most V4l2 webcam drivers I've tried don't support this,
; so they ignore it and give you an RGB (well, BGR in OpenCV)
; image anyway -- but the Pi Cam seems to support it! which saves
; us some CPU cycles.
convert_rgb = true

; if the webcam image is RGB, converts to YUV.
convert_yuv = true

[gui]
; if headless, no GUI is shown at all. this reduces CPU usage.
headless = false
; how long to wait for key input (to advance frame by frame).
; -1 is forever, 0 is not at all, >=1 is time in milliseconds.
waitKey = 1
; if debug is true, it'll spit more info out on command line.
debug = true
; if save_video is not none, it'll save debug output to this file.
; save_video = /tmp/quadtargetfsm_webcam.avi
save_video = none
; if show_state is true, show the state of the state machines
; (in the output image).
show_state = false

[parameters]
; (int) skip every N rows of the image
row_step = 3

; (int) minimum number of pixels needed in state 1 of the state machine.
min_length = 1

; (double) amount of variation in pixel counts that each state can have
; compared to state 1.
tolerance = 0.4

; (int) number of threshold levels used.
num_bins = 5

; (double) amount that the marker aspect ratio can vary
; (with 0.0 being completely square)
marker_aspect_tolerance = 0.3

; (double) minimum distance between markers in a target
min_marker_distance = 0.5

; (double) maximum distance between markers in a target
max_marker_distance = 3.0

; (double) amount that the marker size can vary in a
; target.
; (actual tolerance = 1.0 - this)
; decreasing this means potentially markers
; with a more skewed perspective will be
; detected.
marker_size_tolerance = 0.7

; (int) amount of frames a target can go undetected before
; it's removed from the list.
target_lifetime = 5

; (double) smoothness factor applied when updating
; existing targets with newly detected ones.
target_alpha = 0.1

; (double) max. amount a new target can differ from an existing
; one and still be used to update the existing target
; (based on position, size and angle)
max_target_difference = 0.1
